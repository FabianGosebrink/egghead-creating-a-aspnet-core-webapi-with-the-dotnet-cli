To create a new asp.net core webapi we can start typing "dotnet new" to see all the templates the dotnet command line interface provides us. One template is the webapi temaplte which we will use in this course. To use it we can type "dotnet new webapi" and this will scaffold all files for a new webapi project inside the current folder.


Lets take a look at all the files which have been created so far. First of all there is a program.cs which represents the entry point of our application.

Here we notice that our webapi is nothing else than a console application "public static void main" taking some arguments. All the method does is starting up a webserver or us, reading the configuration files, and useing a startup class to configure all the services and the pipeline for our application.

Lets take a look at the startup.cs file. as we configured our webapi in the first step the configruation gets automatically passed into the constructor of the Class. So if you read a json file from your system which holds your configuration you can access it via the configuration propertyy inside this startup class. 

Other methods are the Configureservies method and the configure method.

The configureservices method gets passed an IServiceCollection which we can use to register our services to the build-in dependency injection system from asp.net core. Here we can choose between three modes: AddSingleton, to register singleton services, add scoped to have an instance of the servies as slong as the http request runs and add transient to get a new instance everytime we inject the service in our application. In this case we will add the required MVC services to our Dependency Injection system.

The Configure Method creates the pipeline for our http request. So an Http request drops in at Line 31 in this case and runs through the whole pipeline where we can add specific middleware if we want our http request run through that. In this case we only add MVC to our request pipeline.

So lets head over to our Controller where our Http-requests can be processed. The Controller is a normal class which inherits from "Controller" and the firs thing you will notice is the Route attibute on top of the class. This represents the string which we have to send our calls to if we want to hook into this particular controller. The next thing youll notice is the "controlle" in those brackets. This will get replaced with the name of the class without the suffix "controller". So in this case the route to recht the controller is "api/values/".

Inside this controller we can Mark our methods with the corresponding HttpVerbs like HttpGet, then we will jump in that method, we can have HttpGet and pass a parameter, we have an HttpPost, Put and Delete.

So lets run this webapi to see if its working. To un it we can simply head over to the console and type "dotnet ruN". This will start a webserver for us and make the api available under localhost:5000. if we head over to our browser and hit localhost:5000/api/values/ we can see the json response "value1" and "Value2 " in this case. Great, so thats working. but we can tweak our API a bit. Lets get back to the code.

So in this get-all method we are very restricted to retrning an IEnumerable of string. we could not give back something else and its not transparent which statuscode is coming back. To improve that we can change the return type to an IActionResult wich is more generic and helps us making our lives easier. To fullfill that IActionResult interface we can use a small helpermethod which is called "ok" taking an object as parameter. So now we do return an 200 Ok statuscode and as a body of the request we are still sending back our string array. Lets adapt that on the other methods, too. The Get method will return just return the value we pass it. The Post Method is retunring an createdAtAction which si a 201 created statuscode- here we can pass the name of the action where the items was created and the item itself. So the link will be sent in the response header and in the body we have the just created object. In this case we will just return the value we parsed from the request body.

The Put method will return an Ok status code and the Delete emthod returns a no content.

Lets see if that still works...so we open up a browser...and if we now call get with a value we get back the number we passed, so that works. Lets see if we can get back all items, too...that works as well. Great. 

back in the code we can also show how to work with objects instead of only strings. therefore we will create a new folder called Models and create a class called "customer". The customer just has a name and an age property on it. back in our controller then we can instead of only returning strings create two customers for example, saying P hil with the age of 60 and mike with the age of 61, and just pass that okay-method a new list containing those customers.

If we start our api again, head over to our browser we can see that the API automatically serializes our classes to json and the two customers are coming back from our get method.

And this is how you can create a webapi in asp.net core with the dotnet cli and visual studio code :)